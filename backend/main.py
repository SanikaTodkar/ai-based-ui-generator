import os
from dotenv import load_dotenv
from openai import OpenAI
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware

from system.validator import validate_tree
from agent.planner import planner
from agent.explainer import explainer
from agent.tree_mutator import create_default_tree, mutate_tree

app = FastAPI()
history = []

load_dotenv()

client = OpenAI(
    api_key=os.getenv("OPENAI_API_KEY"),
    base_url=os.getenv("OPENAI_BASE_URL")
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# -------- TREE â†’ JSX CONVERTER --------
def tree_to_jsx(node, indent=0):
    space = "  " * indent
    props = node.get("props", {})
    children = node.get("children", [])

    props_str = " ".join(f'{k}="{v}"' for k, v in props.items())
    props_str = f" {props_str}" if props_str else ""

    if not children:
        return f"{space}<{node['type']}{props_str} />"

    inner_list = [tree_to_jsx(child, indent + 1) for child in children]
    inner = "\n".join(inner_list)
    return f"{space}<{node['type']}{props_str}>\n{inner}\n{space}</{node['type']}>"



def normalize_tree(node):
    if not isinstance(node, dict):
        return None

    node_type = node.get("type")
    if not isinstance(node_type, str) or not node_type:
        return None

    props = node.get("props")
    if not isinstance(props, dict):
        props = {}

    children = node.get("children")
    if not isinstance(children, list):
        children = []

    cleaned_children = []
    for child in children:
        normalized_child = normalize_tree(child)
        if normalized_child:
            cleaned_children.append(normalized_child)

    return {
        "type": node_type,
        "props": props,
        "children": cleaned_children
    }


@app.post("/agent")
def run_agent(data: dict):
    global history

    new_tree = None

    user_input = data.get("message")
    if not user_input:
        raise HTTPException(status_code=400, detail="Message is required")

    previous_tree = history[-1] if history else None

    try:
        plan = planner(client, user_input)

        intent = plan.get("intent")
        nodes = plan.get("nodes", [])

        # ---------------- CREATE ----------------
        if intent == "create" and nodes:

            root = nodes[0]

            for node in nodes[1:]:
                root.setdefault("children", [])
                root["children"].append(node)

            new_tree = root

        # ---------------- ADD ----------------
        elif intent == "add" and nodes and previous_tree:

            for node in nodes:
                previous_tree.setdefault("children", [])
                previous_tree["children"].append(node)

            new_tree = previous_tree

        # ---------------- MODIFY ----------------
        elif intent == "modify" and nodes and previous_tree:
            for node in nodes:
                for child in previous_tree.get("children", []):
                    if child["type"] == node["type"]:

                        target_label = node.get("props", {}).get("label")
                        existing_label = child.get("props", {}).get("label")

                        if target_label and existing_label:
                            if target_label.lower() == existing_label.lower():
                                child["props"].update(node.get("props", {}))
                        else:
                            child["props"].update(node.get("props", {}))

        # ---------------- REMOVE ----------------
        elif intent == "remove" and nodes and previous_tree:

            for node in nodes:
                previous_tree["children"] = [
                    child for child in previous_tree.get("children", [])
                    if child["type"] != node["type"]
                ]

            new_tree = previous_tree

        # ---------------- FALLBACK ----------------
        else:
            new_tree = previous_tree if previous_tree else None

        if not new_tree:
            raise HTTPException(status_code=400, detail="No valid UI generated")

        normalized_tree = normalize_tree(new_tree)

        if not normalized_tree or not normalized_tree.get("type"):
            raise ValueError("Invalid tree generated by planner.")
        
        validated_tree = validate_tree(normalized_tree)
        history.append(validated_tree)

        jsx_code = tree_to_jsx(validated_tree)

        explanation = explainer(
            plan=plan,
            new_tree=validated_tree,
            previous_tree=previous_tree
        )

        return {
            "tree": validated_tree,
            "code": jsx_code,
            "explanation": explanation,
            "history_length": len(history)
        }

    except Exception as e:
        print("Error occured: ")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/rollback")
def rollback():
    global history
    if len(history) <= 1:
        raise HTTPException(status_code=400, detail="No previous version available")

    history.pop()
    jsx_code = tree_to_jsx(history[-1])

    return {
        "tree": history[-1],
        "code": jsx_code,
        "history_length": len(history)
    }


@app.post("/clear")
def clear_history():
    global history
    history = []
    return {"message": "History cleared"}
